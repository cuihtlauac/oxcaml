(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension layouts_beta -extension simd_beta";
 flambda2;
 stack-allocation;
 arch_amd64;
 native;
*)
(** This is code generated by [generate_makearray_dynamic_tests.ml]. *)


open Stdlib_upstream_compatible
open Stdlib_stable
module List = ListLabels
module String = StringLabels

external[@layout_poly] makearray_dynamic_uninit_local :
  ('a : any_non_null) . int -> 'a array @ local =
  "%makearray_dynamic_uninit"

external[@layout_poly] makearray_dynamic_uninit :
  ('a : any_non_null) . int -> 'a array =
  "%makearray_dynamic_uninit"

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] unsafe_blit :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> ('a array[@local_opt]) -> (int[@local_opt]) -> (int[@local_opt]) -> unit =
  "%arrayblit"

let failwithf fmt = Printf.ksprintf failwith fmt
let printf = Printf.printf

external globalize : local_ 'a -> 'a = "%obj_dup";;

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

let tests_run = ref []

let test_failed = ref false

let mark_test_run test_id =
  if not (List.mem ~set:!tests_run test_id) then
    tests_run := test_id :: !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30; 31; 32 ]

let bad_indices size =
  [ -100; -2; -1; size; size + 1; size + 100; Int.min_int; Int.max_int ]

let blit_offsets size =
  let candidates = [ 0; 1; size / 3; size / 2; size - 1; size ] in
  List.filter candidates ~f:(fun ofs -> ofs > 0 && ofs < size)
  |> List.sort_uniq ~cmp:Int.compare

let blit_lens ~ofs1 ~ofs2 ~size1 ~size2 =
  let len_until_end = Int.min (size1 - ofs1) (size2 - ofs2) in
  let candidates = [ 0; 1; size1 / 2; len_until_end - 1; len_until_end ] in
  List.filter candidates ~f:(fun len -> ofs1 + len <= size1 && ofs2 + len <= size2)
  |> List.sort_uniq ~cmp:Int.compare

type ur1 = #{ a : int64#; b : float# }
and ur2 = #{ a : int64#; b : int }
and ur3 = #{ a : int64# }
and ur4 = #{ a : ur1; b : ur3 }
and enum3 = A3_0 | A3_1 | A3_2

(* Catch metaprogramming errors early *)
let () =
  (* Check types and constants *)
  let _ : float32# = #0.s in
  let _ : float# = #0. in
  let _ : int32# = #0l in
  let _ : int64# = #0L in
  let _ : nativeint# = #0n in
  let _ : ur1 = (#{ a = #0L; b = #0. } : ur1) in
  let _ : ur3 = (#{ a = #0L } : ur3) in
  let _ : ur4 = (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
  let _ : #(float# * int32# * int64#) = #(#0., #0l, #0L) in
  let _ : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) = #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  let _ : #(int64# * ur1) = #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
  let _ : float32 = 0.s in
  let _ : float = 0. in
  let _ : int32 = 0l in
  let _ : int64 = 0L in
  let _ : nativeint = 0n in
  let _ : int = 0 in
  let _ : enum3 = A3_0 in
  let _ : ur2 = (#{ a = #0L; b = 0 } : ur2) in
  let _ : #(int * int64) = #(0, 0L) in
  let _ : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) = #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  let _ : #(float * float * float) = #(0., 0., 0.) in
  let _ : #(float * #(float * float) * #(float * #(float * float * float))) = #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
  let _ : #(float# * int * int64#) = #(#0., 0, #0L) in
  let _ : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) = #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
  let _ : #(ur2 * ur1) = #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* Check equality and mk_value functions *)
  let eq : float32# @ local -> float32# @ local -> bool = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  mark_test_run 1;
  let test = eq (mk_value 1) #1.s in
  if not test then (printf "test 1 failed\n"; test_failed := true);
  mark_test_run 2;
  let test = eq #1.s #1.s in
  if not test then (printf "test 2 failed\n"; test_failed := true);
  mark_test_run 3;
  let test = not (eq #1.s #2.s) in
  if not test then (printf "test 3 failed\n"; test_failed := true);
  let eq : float# @ local -> float# @ local -> bool = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  mark_test_run 4;
  let test = eq (mk_value 1) #1. in
  if not test then (printf "test 4 failed\n"; test_failed := true);
  mark_test_run 5;
  let test = eq #1. #1. in
  if not test then (printf "test 5 failed\n"; test_failed := true);
  mark_test_run 6;
  let test = not (eq #1. #2.) in
  if not test then (printf "test 6 failed\n"; test_failed := true);
  let eq : int32# @ local -> int32# @ local -> bool = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  mark_test_run 7;
  let test = eq (mk_value 1) #1l in
  if not test then (printf "test 7 failed\n"; test_failed := true);
  mark_test_run 8;
  let test = eq #1l #1l in
  if not test then (printf "test 8 failed\n"; test_failed := true);
  mark_test_run 9;
  let test = not (eq #1l #2l) in
  if not test then (printf "test 9 failed\n"; test_failed := true);
  let eq : int64# @ local -> int64# @ local -> bool = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  mark_test_run 10;
  let test = eq (mk_value 1) #1L in
  if not test then (printf "test 10 failed\n"; test_failed := true);
  mark_test_run 11;
  let test = eq #1L #1L in
  if not test then (printf "test 11 failed\n"; test_failed := true);
  mark_test_run 12;
  let test = not (eq #1L #2L) in
  if not test then (printf "test 12 failed\n"; test_failed := true);
  let eq : nativeint# @ local -> nativeint# @ local -> bool = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  mark_test_run 13;
  let test = eq (mk_value 1) #1n in
  if not test then (printf "test 13 failed\n"; test_failed := true);
  mark_test_run 14;
  let test = eq #1n #1n in
  if not test then (printf "test 14 failed\n"; test_failed := true);
  mark_test_run 15;
  let test = not (eq #1n #2n) in
  if not test then (printf "test 15 failed\n"; test_failed := true);
  let eq : ur1 @ local -> ur1 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  mark_test_run 16;
  let test = eq (mk_value 1) (#{ a = #1L; b = #1. } : ur1) in
  if not test then (printf "test 16 failed\n"; test_failed := true);
  mark_test_run 17;
  let test = eq (#{ a = #1L; b = #1. } : ur1) (#{ a = #1L; b = #1. } : ur1) in
  if not test then (printf "test 17 failed\n"; test_failed := true);
  mark_test_run 18;
  let test = not (eq (#{ a = #1L; b = #1. } : ur1) (#{ a = #2L; b = #2. } : ur1)) in
  if not test then (printf "test 18 failed\n"; test_failed := true);
  let eq : ur3 @ local -> ur3 @ local -> bool = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  mark_test_run 19;
  let test = eq (mk_value 1) (#{ a = #1L } : ur3) in
  if not test then (printf "test 19 failed\n"; test_failed := true);
  mark_test_run 20;
  let test = eq (#{ a = #1L } : ur3) (#{ a = #1L } : ur3) in
  if not test then (printf "test 20 failed\n"; test_failed := true);
  mark_test_run 21;
  let test = not (eq (#{ a = #1L } : ur3) (#{ a = #2L } : ur3)) in
  if not test then (printf "test 21 failed\n"; test_failed := true);
  let eq : ur4 @ local -> ur4 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  mark_test_run 22;
  let test = eq (mk_value 1) (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) in
  if not test then (printf "test 22 failed\n"; test_failed := true);
  mark_test_run 23;
  let test = eq (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) in
  if not test then (printf "test 23 failed\n"; test_failed := true);
  mark_test_run 24;
  let test = not (eq (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) (#{ a = (#{ a = #2L; b = #2. } : ur1); b = (#{ a = #2L } : ur3) } : ur4)) in
  if not test then (printf "test 24 failed\n"; test_failed := true);
  let eq : #(float# * int32# * int64#) @ local -> #(float# * int32# * int64#) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  mark_test_run 25;
  let test = eq (mk_value 1) #(#1., #1l, #1L) in
  if not test then (printf "test 25 failed\n"; test_failed := true);
  mark_test_run 26;
  let test = eq #(#1., #1l, #1L) #(#1., #1l, #1L) in
  if not test then (printf "test 26 failed\n"; test_failed := true);
  mark_test_run 27;
  let test = not (eq #(#1., #1l, #1L) #(#2., #2l, #2L)) in
  if not test then (printf "test 27 failed\n"; test_failed := true);
  let eq : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  mark_test_run 28;
  let test = eq (mk_value 1) #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) in
  if not test then (printf "test 28 failed\n"; test_failed := true);
  mark_test_run 29;
  let test = eq #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) in
  if not test then (printf "test 29 failed\n"; test_failed := true);
  mark_test_run 30;
  let test = not (eq #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) #(#2., #(#2L, #2L), #2.s, #(#2l, #(#2.s, #2.)), #2L)) in
  if not test then (printf "test 30 failed\n"; test_failed := true);
  let eq : #(int64# * ur1) @ local -> #(int64# * ur1) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  mark_test_run 31;
  let test = eq (mk_value 1) #(#1L, (#{ a = #1L; b = #1. } : ur1)) in
  if not test then (printf "test 31 failed\n"; test_failed := true);
  mark_test_run 32;
  let test = eq #(#1L, (#{ a = #1L; b = #1. } : ur1)) #(#1L, (#{ a = #1L; b = #1. } : ur1)) in
  if not test then (printf "test 32 failed\n"; test_failed := true);
  mark_test_run 33;
  let test = not (eq #(#1L, (#{ a = #1L; b = #1. } : ur1)) #(#2L, (#{ a = #2L; b = #2. } : ur1))) in
  if not test then (printf "test 33 failed\n"; test_failed := true);
  let eq : float32 @ local -> float32 @ local -> bool = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int i in
  mark_test_run 34;
  let test = eq (mk_value 1) 1.s in
  if not test then (printf "test 34 failed\n"; test_failed := true);
  mark_test_run 35;
  let test = eq 1.s 1.s in
  if not test then (printf "test 35 failed\n"; test_failed := true);
  mark_test_run 36;
  let test = not (eq 1.s 2.s) in
  if not test then (printf "test 36 failed\n"; test_failed := true);
  let eq : float @ local -> float @ local -> bool = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let mk_value i = Float.of_int i in
  mark_test_run 37;
  let test = eq (mk_value 1) 1. in
  if not test then (printf "test 37 failed\n"; test_failed := true);
  mark_test_run 38;
  let test = eq 1. 1. in
  if not test then (printf "test 38 failed\n"; test_failed := true);
  mark_test_run 39;
  let test = not (eq 1. 2.) in
  if not test then (printf "test 39 failed\n"; test_failed := true);
  let eq : int32 @ local -> int32 @ local -> bool = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int i in
  mark_test_run 40;
  let test = eq (mk_value 1) 1l in
  if not test then (printf "test 40 failed\n"; test_failed := true);
  mark_test_run 41;
  let test = eq 1l 1l in
  if not test then (printf "test 41 failed\n"; test_failed := true);
  mark_test_run 42;
  let test = not (eq 1l 2l) in
  if not test then (printf "test 42 failed\n"; test_failed := true);
  let eq : int64 @ local -> int64 @ local -> bool = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int i in
  mark_test_run 43;
  let test = eq (mk_value 1) 1L in
  if not test then (printf "test 43 failed\n"; test_failed := true);
  mark_test_run 44;
  let test = eq 1L 1L in
  if not test then (printf "test 44 failed\n"; test_failed := true);
  mark_test_run 45;
  let test = not (eq 1L 2L) in
  if not test then (printf "test 45 failed\n"; test_failed := true);
  let eq : nativeint @ local -> nativeint @ local -> bool = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  mark_test_run 46;
  let test = eq (mk_value 1) 1n in
  if not test then (printf "test 46 failed\n"; test_failed := true);
  mark_test_run 47;
  let test = eq 1n 1n in
  if not test then (printf "test 47 failed\n"; test_failed := true);
  mark_test_run 48;
  let test = not (eq 1n 2n) in
  if not test then (printf "test 48 failed\n"; test_failed := true);
  let eq : int @ local -> int @ local -> bool = (fun a b -> Int.equal a b) in
  let mk_value i = i in
  mark_test_run 49;
  let test = eq (mk_value 1) 1 in
  if not test then (printf "test 49 failed\n"; test_failed := true);
  mark_test_run 50;
  let test = eq 1 1 in
  if not test then (printf "test 50 failed\n"; test_failed := true);
  mark_test_run 51;
  let test = not (eq 1 2) in
  if not test then (printf "test 51 failed\n"; test_failed := true);
  let eq : enum3 @ local -> enum3 @ local -> bool = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem i 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  mark_test_run 52;
  let test = eq (mk_value 1) A3_1 in
  if not test then (printf "test 52 failed\n"; test_failed := true);
  mark_test_run 53;
  let test = eq A3_1 A3_1 in
  if not test then (printf "test 53 failed\n"; test_failed := true);
  mark_test_run 54;
  let test = not (eq A3_1 A3_2) in
  if not test then (printf "test 54 failed\n"; test_failed := true);
  let eq : ur2 @ local -> ur2 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = i } : ur2) in
  mark_test_run 55;
  let test = eq (mk_value 1) (#{ a = #1L; b = 1 } : ur2) in
  if not test then (printf "test 55 failed\n"; test_failed := true);
  mark_test_run 56;
  let test = eq (#{ a = #1L; b = 1 } : ur2) (#{ a = #1L; b = 1 } : ur2) in
  if not test then (printf "test 56 failed\n"; test_failed := true);
  mark_test_run 57;
  let test = not (eq (#{ a = #1L; b = 1 } : ur2) (#{ a = #2L; b = 2 } : ur2)) in
  if not test then (printf "test 57 failed\n"; test_failed := true);
  let eq : #(int * int64) @ local -> #(int * int64) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i, Int64.of_int i) in
  mark_test_run 58;
  let test = eq (mk_value 1) #(1, 1L) in
  if not test then (printf "test 58 failed\n"; test_failed := true);
  mark_test_run 59;
  let test = eq #(1, 1L) #(1, 1L) in
  if not test then (printf "test 59 failed\n"; test_failed := true);
  mark_test_run 60;
  let test = not (eq #(1, 1L) #(2, 2L)) in
  if not test then (printf "test 60 failed\n"; test_failed := true);
  let eq : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) @ local -> #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  mark_test_run 61;
  let test = eq (mk_value 1) #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) in
  if not test then (printf "test 61 failed\n"; test_failed := true);
  mark_test_run 62;
  let test = eq #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) in
  if not test then (printf "test 62 failed\n"; test_failed := true);
  mark_test_run 63;
  let test = not (eq #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) #(Some 2L, #(2, 2l, 2.), 2., #(2.s, Some (2n, 2n)), 2l)) in
  if not test then (printf "test 63 failed\n"; test_failed := true);
  let eq : #(float * float * float) @ local -> #(float * float * float) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int i, Float.of_int i, Float.of_int i) in
  mark_test_run 64;
  let test = eq (mk_value 1) #(1., 1., 1.) in
  if not test then (printf "test 64 failed\n"; test_failed := true);
  mark_test_run 65;
  let test = eq #(1., 1., 1.) #(1., 1., 1.) in
  if not test then (printf "test 65 failed\n"; test_failed := true);
  mark_test_run 66;
  let test = not (eq #(1., 1., 1.) #(2., 2., 2.)) in
  if not test then (printf "test 66 failed\n"; test_failed := true);
  let eq : #(float * #(float * float) * #(float * #(float * float * float))) @ local -> #(float * #(float * float) * #(float * #(float * float * float))) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int i, #(Float.of_int i, Float.of_int i), #(Float.of_int i, #(Float.of_int i, Float.of_int i, Float.of_int i))) in
  mark_test_run 67;
  let test = eq (mk_value 1) #(1., #(1., 1.), #(1., #(1., 1., 1.))) in
  if not test then (printf "test 67 failed\n"; test_failed := true);
  mark_test_run 68;
  let test = eq #(1., #(1., 1.), #(1., #(1., 1., 1.))) #(1., #(1., 1.), #(1., #(1., 1., 1.))) in
  if not test then (printf "test 68 failed\n"; test_failed := true);
  mark_test_run 69;
  let test = not (eq #(1., #(1., 1.), #(1., #(1., 1., 1.))) #(2., #(2., 2.), #(2., #(2., 2., 2.)))) in
  if not test then (printf "test 69 failed\n"; test_failed := true);
  let eq : #(float# * int * int64#) @ local -> #(float# * int * int64#) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int.equal a b) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, i, Int64_u.of_int i) in
  mark_test_run 70;
  let test = eq (mk_value 1) #(#1., 1, #1L) in
  if not test then (printf "test 70 failed\n"; test_failed := true);
  mark_test_run 71;
  let test = eq #(#1., 1, #1L) #(#1., 1, #1L) in
  if not test then (printf "test 71 failed\n"; test_failed := true);
  mark_test_run 72;
  let test = not (eq #(#1., 1, #1L) #(#2., 2, #2L)) in
  if not test then (printf "test 72 failed\n"; test_failed := true);
  let eq : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) @ local -> #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int.equal a b) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), i) in
  mark_test_run 73;
  let test = eq (mk_value 1) #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) in
  if not test then (printf "test 73 failed\n"; test_failed := true);
  mark_test_run 74;
  let test = eq #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) in
  if not test then (printf "test 74 failed\n"; test_failed := true);
  mark_test_run 75;
  let test = not (eq #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) #(#2., #(2, #2L), #2.s, #(#2l, #(#2.s, #2.)), 2)) in
  if not test then (printf "test 75 failed\n"; test_failed := true);
  let eq : #(ur2 * ur1) @ local -> #(ur2 * ur1) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  mark_test_run 76;
  let test = eq (mk_value 1) #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) in
  if not test then (printf "test 76 failed\n"; test_failed := true);
  mark_test_run 77;
  let test = eq #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) in
  if not test then (printf "test 77 failed\n"; test_failed := true);
  mark_test_run 78;
  let test = not (eq #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) #((#{ a = #2L; b = 2 } : ur2), (#{ a = #2L; b = #2. } : ur1))) in
  if not test then (printf "test 78 failed\n"; test_failed := true);
  (* Check always-GC-ignored types *)
  let _ = (makearray_dynamic_uninit 1 : float32# array) in
  let _ = (makearray_dynamic_uninit 1 : float# array) in
  let _ = (makearray_dynamic_uninit 1 : int32# array) in
  let _ = (makearray_dynamic_uninit 1 : int64# array) in
  let _ = (makearray_dynamic_uninit 1 : nativeint# array) in
  let _ = (makearray_dynamic_uninit 1 : ur1 array) in
  let _ = (makearray_dynamic_uninit 1 : ur3 array) in
  let _ = (makearray_dynamic_uninit 1 : ur4 array) in
  let _ = (makearray_dynamic_uninit 1 : #(float# * int32# * int64#) array) in
  let _ = (makearray_dynamic_uninit 1 : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array) in
  let _ = (makearray_dynamic_uninit 1 : #(int64# * ur1) array) in
  ()
;;

let test_makearray_dynamic size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic size #0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 79;
    let test = eq el #0.s in
    if not test then (printf "test 79 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 80;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 80 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 81;
    let test = raises in
    if not test then (printf "test 81 failed %s %d %d\n" "float32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 82;
    let test = raises in
    if not test then (printf "test 82 failed %s %d %d\n" "float32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 83;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 83 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 84;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 84 failed %s %d %d %d %d %d\n" "float32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 85;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 85 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 86;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 86 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic size #0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 87;
    let test = eq el #0. in
    if not test then (printf "test 87 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 88;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 88 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 89;
    let test = raises in
    if not test then (printf "test 89 failed %s %d %d\n" "float#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 90;
    let test = raises in
    if not test then (printf "test 90 failed %s %d %d\n" "float#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 91 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 92;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 92 failed %s %d %d %d %d %d\n" "float#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 93;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 93 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 94;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 94 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 95;
    let test = eq el #0l in
    if not test then (printf "test 95 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 96 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 97;
    let test = raises in
    if not test then (printf "test 97 failed %s %d %d\n" "int32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 98;
    let test = raises in
    if not test then (printf "test 98 failed %s %d %d\n" "int32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 99;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 99 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 100;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 100 failed %s %d %d %d %d %d\n" "int32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 101;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 101 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 102;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 102 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 103;
    let test = eq el #0L in
    if not test then (printf "test 103 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 104;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 104 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 105;
    let test = raises in
    if not test then (printf "test 105 failed %s %d %d\n" "int64#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 106;
    let test = raises in
    if not test then (printf "test 106 failed %s %d %d\n" "int64#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 107 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 108;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 108 failed %s %d %d %d %d %d\n" "int64#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 109;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 109 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 110;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 110 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 111;
    let test = eq el #0n in
    if not test then (printf "test 111 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 112;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 112 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 113;
    let test = raises in
    if not test then (printf "test 113 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 114;
    let test = raises in
    if not test then (printf "test 114 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 115;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 115 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 116;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 116 failed %s %d %d %d %d %d\n" "nativeint#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 117;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 117 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 118;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 118 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic size (#{ a = #0L; b = #0. } : ur1) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 119;
    let test = eq el (#{ a = #0L; b = #0. } : ur1) in
    if not test then (printf "test 119 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 120 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 121;
    let test = raises in
    if not test then (printf "test 121 failed %s %d %d\n" "ur1" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 122;
    let test = raises in
    if not test then (printf "test 122 failed %s %d %d\n" "ur1" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 123;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 123 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 124;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 124 failed %s %d %d %d %d %d\n" "ur1" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 125;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 125 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 126;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 126 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic size (#{ a = #0L } : ur3) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 127;
    let test = eq el (#{ a = #0L } : ur3) in
    if not test then (printf "test 127 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 128;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 128 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 129;
    let test = raises in
    if not test then (printf "test 129 failed %s %d %d\n" "ur3" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 130;
    let test = raises in
    if not test then (printf "test 130 failed %s %d %d\n" "ur3" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 131 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 132;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 132 failed %s %d %d %d %d %d\n" "ur3" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 133;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 133 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 134;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 134 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic size (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 135;
    let test = eq el (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
    if not test then (printf "test 135 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 136;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 136 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 137;
    let test = raises in
    if not test then (printf "test 137 failed %s %d %d\n" "ur4" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 138;
    let test = raises in
    if not test then (printf "test 138 failed %s %d %d\n" "ur4" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 139;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 139 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 140;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 140 failed %s %d %d %d %d %d\n" "ur4" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 141;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 141 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 142;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 142 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic size #(#0., #0l, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 143;
    let test = eq el #(#0., #0l, #0L) in
    if not test then (printf "test 143 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 144;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 144 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 145;
    let test = raises in
    if not test then (printf "test 145 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 146;
    let test = raises in
    if not test then (printf "test 146 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 147;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 147 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 148;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 148 failed %s %d %d %d %d %d\n" "#(float# * int32# * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 149;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 149 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 150;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 150 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic size #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 151;
    let test = eq el #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
    if not test then (printf "test 151 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 152;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 152 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 153;
    let test = raises in
    if not test then (printf "test 153 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 154;
    let test = raises in
    if not test then (printf "test 154 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 155;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 155 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 156;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 156 failed %s %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 157;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 157 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 158;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 158 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic size #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 159;
    let test = eq el #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
    if not test then (printf "test 159 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 160;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 160 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 161;
    let test = raises in
    if not test then (printf "test 161 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 162;
    let test = raises in
    if not test then (printf "test 162 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 163;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 163 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 164;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 164 failed %s %d %d %d %d %d\n" "#(int64# * ur1)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 165;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 165 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 166;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 166 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic size 0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 167;
    let test = eq el 0.s in
    if not test then (printf "test 167 failed %s %d %d\n" "float32" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 168;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 168 failed %s %d %d\n" "float32" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 169;
    let test = raises in
    if not test then (printf "test 169 failed %s %d %d\n" "float32" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 170;
    let test = raises in
    if not test then (printf "test 170 failed %s %d %d\n" "float32" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 171;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 171 failed %s %d %d\n" "float32" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 172;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 172 failed %s %d %d %d %d %d\n" "float32" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 173;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 173 failed %s %d %d %d %d %d %d\n" "float32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 174;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 174 failed %s %d %d %d %d %d %d\n" "float32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   float   *)
  (*************)
  let eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let mk_value i = Float.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float array = makearray_dynamic size 0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 175;
    let test = eq el 0. in
    if not test then (printf "test 175 failed %s %d %d\n" "float" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 176;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 176 failed %s %d %d\n" "float" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 177;
    let test = raises in
    if not test then (printf "test 177 failed %s %d %d\n" "float" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 178;
    let test = raises in
    if not test then (printf "test 178 failed %s %d %d\n" "float" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 179;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 179 failed %s %d %d\n" "float" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 180;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 180 failed %s %d %d %d %d %d\n" "float" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 181;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 181 failed %s %d %d %d %d %d %d\n" "float" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 182;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 182 failed %s %d %d %d %d %d %d\n" "float" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic size 0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 183;
    let test = eq el 0l in
    if not test then (printf "test 183 failed %s %d %d\n" "int32" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 184;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 184 failed %s %d %d\n" "int32" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 185;
    let test = raises in
    if not test then (printf "test 185 failed %s %d %d\n" "int32" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 186;
    let test = raises in
    if not test then (printf "test 186 failed %s %d %d\n" "int32" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 187;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 187 failed %s %d %d\n" "int32" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 188;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 188 failed %s %d %d %d %d %d\n" "int32" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 189;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 189 failed %s %d %d %d %d %d %d\n" "int32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 190;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 190 failed %s %d %d %d %d %d %d\n" "int32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 191;
    let test = eq el 0L in
    if not test then (printf "test 191 failed %s %d %d\n" "int64" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 192;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 192 failed %s %d %d\n" "int64" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 193;
    let test = raises in
    if not test then (printf "test 193 failed %s %d %d\n" "int64" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 194;
    let test = raises in
    if not test then (printf "test 194 failed %s %d %d\n" "int64" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 195;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 195 failed %s %d %d\n" "int64" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 196;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 196 failed %s %d %d %d %d %d\n" "int64" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 197;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 197 failed %s %d %d %d %d %d %d\n" "int64" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 198;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 198 failed %s %d %d %d %d %d %d\n" "int64" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic size 0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 199;
    let test = eq el 0n in
    if not test then (printf "test 199 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 200;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 200 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 201;
    let test = raises in
    if not test then (printf "test 201 failed %s %d %d\n" "nativeint" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 202;
    let test = raises in
    if not test then (printf "test 202 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 203;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 203 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 204;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 204 failed %s %d %d %d %d %d\n" "nativeint" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 205;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 205 failed %s %d %d %d %d %d %d\n" "nativeint" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 206;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 206 failed %s %d %d %d %d %d %d\n" "nativeint" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = i in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 207;
    let test = eq el 0 in
    if not test then (printf "test 207 failed %s %d %d\n" "int" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 208;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 208 failed %s %d %d\n" "int" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 209;
    let test = raises in
    if not test then (printf "test 209 failed %s %d %d\n" "int" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 210;
    let test = raises in
    if not test then (printf "test 210 failed %s %d %d\n" "int" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 211;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 211 failed %s %d %d\n" "int" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 212;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 212 failed %s %d %d %d %d %d\n" "int" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 213;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 213 failed %s %d %d %d %d %d %d\n" "int" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 214;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 214 failed %s %d %d %d %d %d %d\n" "int" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   enum3   *)
  (*************)
  let eq = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem i 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  (* 1. Create an array of size [size] *)
  let a : enum3 array = makearray_dynamic size A3_0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 215;
    let test = eq el A3_0 in
    if not test then (printf "test 215 failed %s %d %d\n" "enum3" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 216;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 216 failed %s %d %d\n" "enum3" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 217;
    let test = raises in
    if not test then (printf "test 217 failed %s %d %d\n" "enum3" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i A3_0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 218;
    let test = raises in
    if not test then (printf "test 218 failed %s %d %d\n" "enum3" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 219;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 219 failed %s %d %d\n" "enum3" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 220;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 220 failed %s %d %d %d %d %d\n" "enum3" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 221;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 221 failed %s %d %d %d %d %d %d\n" "enum3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 222;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 222 failed %s %d %d %d %d %d %d\n" "enum3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur2   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = i } : ur2) in
  (* 1. Create an array of size [size] *)
  let a : ur2 array = makearray_dynamic size (#{ a = #0L; b = 0 } : ur2) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 223;
    let test = eq el (#{ a = #0L; b = 0 } : ur2) in
    if not test then (printf "test 223 failed %s %d %d\n" "ur2" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 224;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 224 failed %s %d %d\n" "ur2" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 225;
    let test = raises in
    if not test then (printf "test 225 failed %s %d %d\n" "ur2" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = 0 } : ur2) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 226;
    let test = raises in
    if not test then (printf "test 226 failed %s %d %d\n" "ur2" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 227;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 227 failed %s %d %d\n" "ur2" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 228;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 228 failed %s %d %d %d %d %d\n" "ur2" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 229;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 229 failed %s %d %d %d %d %d %d\n" "ur2" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 230;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 230 failed %s %d %d %d %d %d %d\n" "ur2" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i, Int64.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic size #(0, 0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 231;
    let test = eq el #(0, 0L) in
    if not test then (printf "test 231 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 232;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 232 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 233;
    let test = raises in
    if not test then (printf "test 233 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0, 0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 234;
    let test = raises in
    if not test then (printf "test 234 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 235;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 235 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 236;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 236 failed %s %d %d %d %d %d\n" "#(int * int64)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 237;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 237 failed %s %d %d %d %d %d %d\n" "#(int * int64)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 238;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 238 failed %s %d %d %d %d %d %d\n" "#(int * int64)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************************************************************************************************************)
  (*   #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)   *)
  (**************************************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) array = makearray_dynamic size #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 239;
    let test = eq el #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
    if not test then (printf "test 239 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 240;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 240 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 241;
    let test = raises in
    if not test then (printf "test 241 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 242;
    let test = raises in
    if not test then (printf "test 242 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 243;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 243 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 244;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 244 failed %s %d %d %d %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 245;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 245 failed %s %d %d %d %d %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 246;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 246 failed %s %d %d %d %d %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int i, Float.of_int i, Float.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic size #(0., 0., 0.) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 247;
    let test = eq el #(0., 0., 0.) in
    if not test then (printf "test 247 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 248;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 248 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 249;
    let test = raises in
    if not test then (printf "test 249 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., 0., 0.) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 250;
    let test = raises in
    if not test then (printf "test 250 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 251;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 251 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 252;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 252 failed %s %d %d %d %d %d\n" "#(float * float * float)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 253;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 253 failed %s %d %d %d %d %d %d\n" "#(float * float * float)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 254;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 254 failed %s %d %d %d %d %d %d\n" "#(float * float * float)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int i, #(Float.of_int i, Float.of_int i), #(Float.of_int i, #(Float.of_int i, Float.of_int i, Float.of_int i))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic size #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 255;
    let test = eq el #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
    if not test then (printf "test 255 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 256;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 256 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 257;
    let test = raises in
    if not test then (printf "test 257 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., #(0., 0.), #(0., #(0., 0., 0.))) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 258;
    let test = raises in
    if not test then (printf "test 258 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 259;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 259 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 260;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 260 failed %s %d %d %d %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 261;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 261 failed %s %d %d %d %d %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 262;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 262 failed %s %d %d %d %d %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float# * int * int64#)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int.equal a b) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int * int64#) array = makearray_dynamic size #(#0., 0, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 263;
    let test = eq el #(#0., 0, #0L) in
    if not test then (printf "test 263 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 264;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 264 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 265;
    let test = raises in
    if not test then (printf "test 265 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., 0, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 266;
    let test = raises in
    if not test then (printf "test 266 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 267;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 267 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 268;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 268 failed %s %d %d %d %d %d\n" "#(float# * int * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 269;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 269 failed %s %d %d %d %d %d %d\n" "#(float# * int * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 270;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 270 failed %s %d %d %d %d %d %d\n" "#(float# * int * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************************************************************************************)
  (*   #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)   *)
  (***************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int.equal a b) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) array = makearray_dynamic size #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 271;
    let test = eq el #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
    if not test then (printf "test 271 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 272;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 272 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 273;
    let test = raises in
    if not test then (printf "test 273 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 274;
    let test = raises in
    if not test then (printf "test 274 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 275;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 275 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 276;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 276 failed %s %d %d %d %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 277;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 277 failed %s %d %d %d %d %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 278;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 278 failed %s %d %d %d %d %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************)
  (*   #(ur2 * ur1)   *)
  (********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(ur2 * ur1) array = makearray_dynamic size #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 279;
    let test = eq el #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
    if not test then (printf "test 279 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 280;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 280 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 281;
    let test = raises in
    if not test then (printf "test 281 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 282;
    let test = raises in
    if not test then (printf "test 282 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 283;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 283 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 284;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 284 failed %s %d %d %d %d %d\n" "#(ur2 * ur1)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 285;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 285 failed %s %d %d %d %d %d %d\n" "#(ur2 * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 286;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 286 failed %s %d %d %d %d %d %d\n" "#(ur2 * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_local size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_local size #0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 287;
    let test = eq el #0.s in
    if not test then (printf "test 287 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 288;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 288 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 289;
    let test = raises in
    if not test then (printf "test 289 failed %s %d %d\n" "float32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 290;
    let test = raises in
    if not test then (printf "test 290 failed %s %d %d\n" "float32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 291;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 291 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 292;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 292 failed %s %d %d %d %d %d\n" "float32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 293;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 293 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 294;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 294 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_local size #0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 295;
    let test = eq el #0. in
    if not test then (printf "test 295 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 296;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 296 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 297;
    let test = raises in
    if not test then (printf "test 297 failed %s %d %d\n" "float#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 298;
    let test = raises in
    if not test then (printf "test 298 failed %s %d %d\n" "float#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 299;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 299 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 300;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 300 failed %s %d %d %d %d %d\n" "float#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 301;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 301 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 302;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 302 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 303;
    let test = eq el #0l in
    if not test then (printf "test 303 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 304;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 304 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 305;
    let test = raises in
    if not test then (printf "test 305 failed %s %d %d\n" "int32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 306;
    let test = raises in
    if not test then (printf "test 306 failed %s %d %d\n" "int32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 307;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 307 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 308;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 308 failed %s %d %d %d %d %d\n" "int32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 309;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 309 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 310;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 310 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 311;
    let test = eq el #0L in
    if not test then (printf "test 311 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 312;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 312 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 313;
    let test = raises in
    if not test then (printf "test 313 failed %s %d %d\n" "int64#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 314;
    let test = raises in
    if not test then (printf "test 314 failed %s %d %d\n" "int64#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 315;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 315 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 316;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 316 failed %s %d %d %d %d %d\n" "int64#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 317;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 317 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 318;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 318 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 319;
    let test = eq el #0n in
    if not test then (printf "test 319 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 320;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 320 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 321;
    let test = raises in
    if not test then (printf "test 321 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 322;
    let test = raises in
    if not test then (printf "test 322 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 323;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 323 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 324;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 324 failed %s %d %d %d %d %d\n" "nativeint#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 325;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 325 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 326;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 326 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_local size (#{ a = #0L; b = #0. } : ur1) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 327;
    let test = eq el (#{ a = #0L; b = #0. } : ur1) in
    if not test then (printf "test 327 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 328;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 328 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 329;
    let test = raises in
    if not test then (printf "test 329 failed %s %d %d\n" "ur1" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 330;
    let test = raises in
    if not test then (printf "test 330 failed %s %d %d\n" "ur1" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 331;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 331 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 332;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 332 failed %s %d %d %d %d %d\n" "ur1" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 333;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 333 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 334;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 334 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_local size (#{ a = #0L } : ur3) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 335;
    let test = eq el (#{ a = #0L } : ur3) in
    if not test then (printf "test 335 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 336;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 336 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 337;
    let test = raises in
    if not test then (printf "test 337 failed %s %d %d\n" "ur3" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 338;
    let test = raises in
    if not test then (printf "test 338 failed %s %d %d\n" "ur3" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 339;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 339 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 340;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 340 failed %s %d %d %d %d %d\n" "ur3" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 341;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 341 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 342;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 342 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_local size (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 343;
    let test = eq el (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
    if not test then (printf "test 343 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 344;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 344 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 345;
    let test = raises in
    if not test then (printf "test 345 failed %s %d %d\n" "ur4" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 346;
    let test = raises in
    if not test then (printf "test 346 failed %s %d %d\n" "ur4" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 347;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 347 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 348;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 348 failed %s %d %d %d %d %d\n" "ur4" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 349;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 349 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 350;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 350 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_local size #(#0., #0l, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 351;
    let test = eq el #(#0., #0l, #0L) in
    if not test then (printf "test 351 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 352;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 352 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 353;
    let test = raises in
    if not test then (printf "test 353 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 354;
    let test = raises in
    if not test then (printf "test 354 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 355;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 355 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 356;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 356 failed %s %d %d %d %d %d\n" "#(float# * int32# * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 357;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 357 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 358;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 358 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_local size #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 359;
    let test = eq el #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
    if not test then (printf "test 359 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 360;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 360 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 361;
    let test = raises in
    if not test then (printf "test 361 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 362;
    let test = raises in
    if not test then (printf "test 362 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 363;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 363 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 364;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 364 failed %s %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 365;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 365 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 366;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 366 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_local size #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 367;
    let test = eq el #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
    if not test then (printf "test 367 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 368;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 368 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 369;
    let test = raises in
    if not test then (printf "test 369 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 370;
    let test = raises in
    if not test then (printf "test 370 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 371;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 371 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 372;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 372 failed %s %d %d %d %d %d\n" "#(int64# * ur1)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 373;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 373 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 374;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 374 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic_local size 0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 375;
    let test = eq el 0.s in
    if not test then (printf "test 375 failed %s %d %d\n" "float32" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 376;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 376 failed %s %d %d\n" "float32" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 377;
    let test = raises in
    if not test then (printf "test 377 failed %s %d %d\n" "float32" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 378;
    let test = raises in
    if not test then (printf "test 378 failed %s %d %d\n" "float32" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 379;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 379 failed %s %d %d\n" "float32" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 380;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 380 failed %s %d %d %d %d %d\n" "float32" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 381;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 381 failed %s %d %d %d %d %d %d\n" "float32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 382;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 382 failed %s %d %d %d %d %d %d\n" "float32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   float   *)
  (*************)
  let eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let mk_value i = Float.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float array = makearray_dynamic_local size 0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 383;
    let test = eq el 0. in
    if not test then (printf "test 383 failed %s %d %d\n" "float" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 384;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 384 failed %s %d %d\n" "float" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 385;
    let test = raises in
    if not test then (printf "test 385 failed %s %d %d\n" "float" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 386;
    let test = raises in
    if not test then (printf "test 386 failed %s %d %d\n" "float" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 387;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 387 failed %s %d %d\n" "float" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 388;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 388 failed %s %d %d %d %d %d\n" "float" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 389;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 389 failed %s %d %d %d %d %d %d\n" "float" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 390;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 390 failed %s %d %d %d %d %d %d\n" "float" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic_local size 0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 391;
    let test = eq el 0l in
    if not test then (printf "test 391 failed %s %d %d\n" "int32" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 392;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 392 failed %s %d %d\n" "int32" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 393;
    let test = raises in
    if not test then (printf "test 393 failed %s %d %d\n" "int32" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 394;
    let test = raises in
    if not test then (printf "test 394 failed %s %d %d\n" "int32" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 395;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 395 failed %s %d %d\n" "int32" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 396;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 396 failed %s %d %d %d %d %d\n" "int32" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 397;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 397 failed %s %d %d %d %d %d %d\n" "int32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 398;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 398 failed %s %d %d %d %d %d %d\n" "int32" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 399;
    let test = eq el 0L in
    if not test then (printf "test 399 failed %s %d %d\n" "int64" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 400;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 400 failed %s %d %d\n" "int64" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 401;
    let test = raises in
    if not test then (printf "test 401 failed %s %d %d\n" "int64" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 402;
    let test = raises in
    if not test then (printf "test 402 failed %s %d %d\n" "int64" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 403;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 403 failed %s %d %d\n" "int64" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 404;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 404 failed %s %d %d %d %d %d\n" "int64" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 405;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 405 failed %s %d %d %d %d %d %d\n" "int64" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 406;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 406 failed %s %d %d %d %d %d %d\n" "int64" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic_local size 0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 407;
    let test = eq el 0n in
    if not test then (printf "test 407 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 408;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 408 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 409;
    let test = raises in
    if not test then (printf "test 409 failed %s %d %d\n" "nativeint" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 410;
    let test = raises in
    if not test then (printf "test 410 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 411;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 411 failed %s %d %d\n" "nativeint" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 412;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 412 failed %s %d %d %d %d %d\n" "nativeint" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 413;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 413 failed %s %d %d %d %d %d %d\n" "nativeint" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 414;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 414 failed %s %d %d %d %d %d %d\n" "nativeint" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = i in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 415;
    let test = eq el 0 in
    if not test then (printf "test 415 failed %s %d %d\n" "int" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 416;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 416 failed %s %d %d\n" "int" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 417;
    let test = raises in
    if not test then (printf "test 417 failed %s %d %d\n" "int" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 418;
    let test = raises in
    if not test then (printf "test 418 failed %s %d %d\n" "int" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 419;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 419 failed %s %d %d\n" "int" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 420;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 420 failed %s %d %d %d %d %d\n" "int" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 421;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 421 failed %s %d %d %d %d %d %d\n" "int" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 422;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 422 failed %s %d %d %d %d %d %d\n" "int" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   enum3   *)
  (*************)
  let eq = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem i 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  (* 1. Create an array of size [size] *)
  let a : enum3 array = makearray_dynamic_local size A3_0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 423;
    let test = eq el A3_0 in
    if not test then (printf "test 423 failed %s %d %d\n" "enum3" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 424;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 424 failed %s %d %d\n" "enum3" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 425;
    let test = raises in
    if not test then (printf "test 425 failed %s %d %d\n" "enum3" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i A3_0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 426;
    let test = raises in
    if not test then (printf "test 426 failed %s %d %d\n" "enum3" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 427;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 427 failed %s %d %d\n" "enum3" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 428;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 428 failed %s %d %d %d %d %d\n" "enum3" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 429;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 429 failed %s %d %d %d %d %d %d\n" "enum3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 430;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 430 failed %s %d %d %d %d %d %d\n" "enum3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur2   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = i } : ur2) in
  (* 1. Create an array of size [size] *)
  let a : ur2 array = makearray_dynamic_local size (#{ a = #0L; b = 0 } : ur2) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 431;
    let test = eq el (#{ a = #0L; b = 0 } : ur2) in
    if not test then (printf "test 431 failed %s %d %d\n" "ur2" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 432;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 432 failed %s %d %d\n" "ur2" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 433;
    let test = raises in
    if not test then (printf "test 433 failed %s %d %d\n" "ur2" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = 0 } : ur2) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 434;
    let test = raises in
    if not test then (printf "test 434 failed %s %d %d\n" "ur2" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 435;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 435 failed %s %d %d\n" "ur2" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 436;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 436 failed %s %d %d %d %d %d\n" "ur2" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 437;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 437 failed %s %d %d %d %d %d %d\n" "ur2" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 438;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 438 failed %s %d %d %d %d %d %d\n" "ur2" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i, Int64.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic_local size #(0, 0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 439;
    let test = eq el #(0, 0L) in
    if not test then (printf "test 439 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 440;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 440 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 441;
    let test = raises in
    if not test then (printf "test 441 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0, 0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 442;
    let test = raises in
    if not test then (printf "test 442 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 443;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 443 failed %s %d %d\n" "#(int * int64)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 444;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 444 failed %s %d %d %d %d %d\n" "#(int * int64)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 445;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 445 failed %s %d %d %d %d %d %d\n" "#(int * int64)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 446;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 446 failed %s %d %d %d %d %d %d\n" "#(int * int64)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************************************************************************************************************)
  (*   #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)   *)
  (**************************************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) array = makearray_dynamic_local size #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 447;
    let test = eq el #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
    if not test then (printf "test 447 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 448;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 448 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 449;
    let test = raises in
    if not test then (printf "test 449 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 450;
    let test = raises in
    if not test then (printf "test 450 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 451;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 451 failed %s %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 452;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 452 failed %s %d %d %d %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 453;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 453 failed %s %d %d %d %d %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 454;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 454 failed %s %d %d %d %d %d %d\n" "#(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int i, Float.of_int i, Float.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic_local size #(0., 0., 0.) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 455;
    let test = eq el #(0., 0., 0.) in
    if not test then (printf "test 455 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 456;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 456 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 457;
    let test = raises in
    if not test then (printf "test 457 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., 0., 0.) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 458;
    let test = raises in
    if not test then (printf "test 458 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 459;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 459 failed %s %d %d\n" "#(float * float * float)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 460;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 460 failed %s %d %d %d %d %d\n" "#(float * float * float)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 461;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 461 failed %s %d %d %d %d %d %d\n" "#(float * float * float)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 462;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 462 failed %s %d %d %d %d %d %d\n" "#(float * float * float)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int i, #(Float.of_int i, Float.of_int i), #(Float.of_int i, #(Float.of_int i, Float.of_int i, Float.of_int i))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic_local size #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 463;
    let test = eq el #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
    if not test then (printf "test 463 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 464;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 464 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 465;
    let test = raises in
    if not test then (printf "test 465 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., #(0., 0.), #(0., #(0., 0., 0.))) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 466;
    let test = raises in
    if not test then (printf "test 466 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 467;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 467 failed %s %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 468;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 468 failed %s %d %d %d %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 469;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 469 failed %s %d %d %d %d %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 470;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 470 failed %s %d %d %d %d %d %d\n" "#(float * #(float * float) * #(float * #(float * float * float)))" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float# * int * int64#)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int.equal a b) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int * int64#) array = makearray_dynamic_local size #(#0., 0, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 471;
    let test = eq el #(#0., 0, #0L) in
    if not test then (printf "test 471 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 472;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 472 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 473;
    let test = raises in
    if not test then (printf "test 473 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., 0, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 474;
    let test = raises in
    if not test then (printf "test 474 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 475;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 475 failed %s %d %d\n" "#(float# * int * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 476;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 476 failed %s %d %d %d %d %d\n" "#(float# * int * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 477;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 477 failed %s %d %d %d %d %d %d\n" "#(float# * int * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 478;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 478 failed %s %d %d %d %d %d %d\n" "#(float# * int * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************************************************************************************)
  (*   #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)   *)
  (***************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int.equal a b) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) array = makearray_dynamic_local size #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 479;
    let test = eq el #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
    if not test then (printf "test 479 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 480;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 480 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 481;
    let test = raises in
    if not test then (printf "test 481 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 482;
    let test = raises in
    if not test then (printf "test 482 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 483;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 483 failed %s %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 484;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 484 failed %s %d %d %d %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 485;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 485 failed %s %d %d %d %d %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 486;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 486 failed %s %d %d %d %d %d %d\n" "#(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************)
  (*   #(ur2 * ur1)   *)
  (********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(ur2 * ur1) array = makearray_dynamic_local size #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 487;
    let test = eq el #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
    if not test then (printf "test 487 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 488;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 488 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 489;
    let test = raises in
    if not test then (printf "test 489 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 490;
    let test = raises in
    if not test then (printf "test 490 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 491;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 491 failed %s %d %d\n" "#(ur2 * ur1)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 492;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 492 failed %s %d %d %d %d %d\n" "#(ur2 * ur1)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 493;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 493 failed %s %d %d %d %d %d %d\n" "#(ur2 * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 494;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 494 failed %s %d %d %d %d %d %d\n" "#(ur2 * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_uninit size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 495;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 495 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 496;
    let test = raises in
    if not test then (printf "test 496 failed %s %d %d\n" "float32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 497;
    let test = raises in
    if not test then (printf "test 497 failed %s %d %d\n" "float32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 498;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 498 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 499;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 499 failed %s %d %d %d %d %d\n" "float32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 500;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 500 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 501;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 501 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 502;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 502 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 503;
    let test = raises in
    if not test then (printf "test 503 failed %s %d %d\n" "float#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 504;
    let test = raises in
    if not test then (printf "test 504 failed %s %d %d\n" "float#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 505;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 505 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 506;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 506 failed %s %d %d %d %d %d\n" "float#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 507;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 507 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 508;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 508 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 509;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 509 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 510;
    let test = raises in
    if not test then (printf "test 510 failed %s %d %d\n" "int32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 511;
    let test = raises in
    if not test then (printf "test 511 failed %s %d %d\n" "int32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 512;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 512 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 513;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 513 failed %s %d %d %d %d %d\n" "int32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 514;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 514 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 515;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 515 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 516;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 516 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 517;
    let test = raises in
    if not test then (printf "test 517 failed %s %d %d\n" "int64#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 518;
    let test = raises in
    if not test then (printf "test 518 failed %s %d %d\n" "int64#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 519;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 519 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 520;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 520 failed %s %d %d %d %d %d\n" "int64#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 521;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 521 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 522;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 522 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 523;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 523 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 524;
    let test = raises in
    if not test then (printf "test 524 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 525;
    let test = raises in
    if not test then (printf "test 525 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 526;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 526 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 527;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 527 failed %s %d %d %d %d %d\n" "nativeint#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 528;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 528 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 529;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 529 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 530;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 530 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 531;
    let test = raises in
    if not test then (printf "test 531 failed %s %d %d\n" "ur1" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 532;
    let test = raises in
    if not test then (printf "test 532 failed %s %d %d\n" "ur1" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 533;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 533 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 534;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 534 failed %s %d %d %d %d %d\n" "ur1" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 535;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 535 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 536;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 536 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 537;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 537 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 538;
    let test = raises in
    if not test then (printf "test 538 failed %s %d %d\n" "ur3" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 539;
    let test = raises in
    if not test then (printf "test 539 failed %s %d %d\n" "ur3" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 540;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 540 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 541;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 541 failed %s %d %d %d %d %d\n" "ur3" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 542;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 542 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 543;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 543 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 544;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 544 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 545;
    let test = raises in
    if not test then (printf "test 545 failed %s %d %d\n" "ur4" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 546;
    let test = raises in
    if not test then (printf "test 546 failed %s %d %d\n" "ur4" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 547;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 547 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 548;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 548 failed %s %d %d %d %d %d\n" "ur4" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 549;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 549 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 550;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 550 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 551;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 551 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 552;
    let test = raises in
    if not test then (printf "test 552 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 553;
    let test = raises in
    if not test then (printf "test 553 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 554;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 554 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 555;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 555 failed %s %d %d %d %d %d\n" "#(float# * int32# * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 556;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 556 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 557;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 557 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 558;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 558 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 559;
    let test = raises in
    if not test then (printf "test 559 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 560;
    let test = raises in
    if not test then (printf "test 560 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 561;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 561 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 562;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 562 failed %s %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 563;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 563 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 564;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 564 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 565;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 565 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 566;
    let test = raises in
    if not test then (printf "test 566 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 567;
    let test = raises in
    if not test then (printf "test 567 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 568;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 568 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 569;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 569 failed %s %d %d %d %d %d\n" "#(int64# * ur1)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 570;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 570 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 571;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 571 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_uninit_local size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 572;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 572 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 573;
    let test = raises in
    if not test then (printf "test 573 failed %s %d %d\n" "float32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 574;
    let test = raises in
    if not test then (printf "test 574 failed %s %d %d\n" "float32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 575;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 575 failed %s %d %d\n" "float32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 576;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 576 failed %s %d %d %d %d %d\n" "float32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 577;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 577 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 578;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 578 failed %s %d %d %d %d %d %d\n" "float32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 579;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 579 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 580;
    let test = raises in
    if not test then (printf "test 580 failed %s %d %d\n" "float#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 581;
    let test = raises in
    if not test then (printf "test 581 failed %s %d %d\n" "float#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 582;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 582 failed %s %d %d\n" "float#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 583;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 583 failed %s %d %d %d %d %d\n" "float#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 584;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 584 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 585;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 585 failed %s %d %d %d %d %d %d\n" "float#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 586;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 586 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 587;
    let test = raises in
    if not test then (printf "test 587 failed %s %d %d\n" "int32#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 588;
    let test = raises in
    if not test then (printf "test 588 failed %s %d %d\n" "int32#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 589;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 589 failed %s %d %d\n" "int32#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 590;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 590 failed %s %d %d %d %d %d\n" "int32#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 591;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 591 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 592;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 592 failed %s %d %d %d %d %d %d\n" "int32#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 593;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 593 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 594;
    let test = raises in
    if not test then (printf "test 594 failed %s %d %d\n" "int64#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 595;
    let test = raises in
    if not test then (printf "test 595 failed %s %d %d\n" "int64#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 596;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 596 failed %s %d %d\n" "int64#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 597;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 597 failed %s %d %d %d %d %d\n" "int64#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 598;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 598 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 599;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 599 failed %s %d %d %d %d %d %d\n" "int64#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 600;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 600 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 601;
    let test = raises in
    if not test then (printf "test 601 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 602;
    let test = raises in
    if not test then (printf "test 602 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 603;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 603 failed %s %d %d\n" "nativeint#" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 604;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 604 failed %s %d %d %d %d %d\n" "nativeint#" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 605;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 605 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 606;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 606 failed %s %d %d %d %d %d %d\n" "nativeint#" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 607;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 607 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 608;
    let test = raises in
    if not test then (printf "test 608 failed %s %d %d\n" "ur1" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 609;
    let test = raises in
    if not test then (printf "test 609 failed %s %d %d\n" "ur1" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 610;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 610 failed %s %d %d\n" "ur1" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 611;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 611 failed %s %d %d %d %d %d\n" "ur1" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 612;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 612 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 613;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 613 failed %s %d %d %d %d %d %d\n" "ur1" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 614;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 614 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 615;
    let test = raises in
    if not test then (printf "test 615 failed %s %d %d\n" "ur3" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 616;
    let test = raises in
    if not test then (printf "test 616 failed %s %d %d\n" "ur3" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 617;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 617 failed %s %d %d\n" "ur3" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 618;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 618 failed %s %d %d %d %d %d\n" "ur3" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 619;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 619 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 620;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 620 failed %s %d %d %d %d %d %d\n" "ur3" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 621;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 621 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 622;
    let test = raises in
    if not test then (printf "test 622 failed %s %d %d\n" "ur4" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 623;
    let test = raises in
    if not test then (printf "test 623 failed %s %d %d\n" "ur4" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 624;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 624 failed %s %d %d\n" "ur4" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 625;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 625 failed %s %d %d %d %d %d\n" "ur4" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 626;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 626 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 627;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 627 failed %s %d %d %d %d %d %d\n" "ur4" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 628;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 628 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 629;
    let test = raises in
    if not test then (printf "test 629 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 630;
    let test = raises in
    if not test then (printf "test 630 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 631;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 631 failed %s %d %d\n" "#(float# * int32# * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 632;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 632 failed %s %d %d %d %d %d\n" "#(float# * int32# * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 633;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 633 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 634;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 634 failed %s %d %d %d %d %d %d\n" "#(float# * int32# * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 635;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 635 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 636;
    let test = raises in
    if not test then (printf "test 636 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 637;
    let test = raises in
    if not test then (printf "test 637 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 638;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 638 failed %s %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 639;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 639 failed %s %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 640;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 640 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 641;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 641 failed %s %d %d %d %d %d %d\n" "#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 642;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 642 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 643;
    let test = raises in
    if not test then (printf "test 643 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 644;
    let test = raises in
    if not test then (printf "test 644 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 645;
    let test = eq (get a i) (mk_value i) in
    if not test then (printf "test 645 failed %s %d %d\n" "#(int64# * ur1)" size i; test_failed := true);
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 646;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then (printf "test 646 failed %s %d %d %d %d %d\n" "#(int64# * ur1)" size ofs1 ofs2 len i; test_failed := true);
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 647;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 647 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 648;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then (printf "test 648 failed %s %d %d %d %d %d %d\n" "#(int64# * ur1)" size size2 ofs1 ofs2 len i; test_failed := true);
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

(* Main tests *)
let () =
  print_endline "test_makearray_dynamic";
  iter sizes ~f:test_makearray_dynamic;
  print_endline "test_makearray_dynamic_local";
  iter sizes ~f:test_makearray_dynamic_local;
  print_endline "test_makearray_dynamic_uninit";
  iter sizes ~f:test_makearray_dynamic_uninit;
  print_endline "test_makearray_dynamic_uninit_local";
  iter sizes ~f:test_makearray_dynamic_uninit_local;
  ()
;;

for i = 1 to 648 do
  if not (List.mem ~set:!tests_run i) then failwithf "test %d not run" i
done;;
if !test_failed then printf "Not all tests passed.\n" else printf "All tests passed.\n"
