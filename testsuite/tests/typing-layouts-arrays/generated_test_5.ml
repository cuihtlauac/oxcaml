(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension layouts_beta -extension simd_beta";
 flambda2;
 stack-allocation;
 arch_amd64;
 native;
*)
(** This is code generated by [generate_makearray_dynamic_tests.ml]. *)


open Stdlib_upstream_compatible
open Stdlib_stable
module List = ListLabels
module String = StringLabels

external[@layout_poly] makearray_dynamic_uninit_local :
  ('a : any_non_null) . int -> 'a array @ local =
  "%makearray_dynamic_uninit"

external[@layout_poly] makearray_dynamic_uninit :
  ('a : any_non_null) . int -> 'a array =
  "%makearray_dynamic_uninit"

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] unsafe_blit :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> ('a array[@local_opt]) -> (int[@local_opt]) -> (int[@local_opt]) -> unit =
  "%arrayblit"

let failwithf fmt = Printf.ksprintf failwith fmt

external globalize : local_ 'a -> 'a = "%obj_dup";;

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

let tests_run = ref []

let mark_test_run test_id =
  if not (List.mem ~set:!tests_run test_id) then
    tests_run := test_id :: !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30; 31; 32 ]

let bad_indices size =
  [ -100; -2; -1; size; size + 1; size + 100; Int.min_int; Int.max_int ]

let blit_offsets size =
  let candidates = [ 0; 1; size / 3; size / 2; size - 1; size ] in
  List.filter candidates ~f:(fun ofs -> ofs > 0 && ofs < size)
  |> List.sort_uniq ~cmp:Int.compare

let blit_lens ~ofs1 ~ofs2 ~size1 ~size2 =
  let len_until_end = Int.min (size1 - ofs1) (size2 - ofs2) in
  let candidates = [ 0; 1; size1 / 2; len_until_end - 1; len_until_end ] in
  List.filter candidates ~f:(fun len -> ofs1 + len <= size1 && ofs2 + len <= size2)
  |> List.sort_uniq ~cmp:Int.compare

type ur1 = #{ a : int64#; b : float# }
and ur2 = #{ a : int64#; b : int }
and ur3 = #{ a : int64# }
and ur4 = #{ a : ur1; b : ur3 }
and enum3 = A3_0 | A3_1 | A3_2

let test_makearray_dynamic size =
  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 1;
    let test = eq el #0n in
    if not test then failwithf "test 1 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 2;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 2 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 3;
    let test = raises in
    if not test then failwithf "test 3 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 4;
    let test = raises in
    if not test then failwithf "test 4 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 5;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 5 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 6;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 6 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 7;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 7 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 8;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 8 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic size #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 9;
    let test = eq el #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
    if not test then failwithf "test 9 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 10;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 10 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 11;
    let test = raises in
    if not test then failwithf "test 11 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 12;
    let test = raises in
    if not test then failwithf "test 12 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 13;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 13 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 14;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 14 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 15;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 15 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 16;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 16 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic size 0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 17;
    let test = eq el 0n in
    if not test then failwithf "test 17 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 18;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 18 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 19;
    let test = raises in
    if not test then failwithf "test 19 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 20;
    let test = raises in
    if not test then failwithf "test 20 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 21;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 21 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 22;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 22 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 23;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 23 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 24;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 24 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************************************************************************************************************)
  (*   #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)   *)
  (**************************************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) array = makearray_dynamic size #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 25;
    let test = eq el #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
    if not test then failwithf "test 25 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 26;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 26 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 27;
    let test = raises in
    if not test then failwithf "test 27 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 28;
    let test = raises in
    if not test then failwithf "test 28 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 29;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 29 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 30;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 30 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 31;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 31 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 32;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 32 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************)
  (*   #(ur2 * ur1)   *)
  (********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(ur2 * ur1) array = makearray_dynamic size #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 33;
    let test = eq el #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
    if not test then failwithf "test 33 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 34;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 34 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 35;
    let test = raises in
    if not test then failwithf "test 35 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 36;
    let test = raises in
    if not test then failwithf "test 36 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 37;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 37 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 38;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 38 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 39;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 39 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 40;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 40 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_local size =
  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 41;
    let test = eq el #0n in
    if not test then failwithf "test 41 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 42;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 42 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 43;
    let test = raises in
    if not test then failwithf "test 43 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 44;
    let test = raises in
    if not test then failwithf "test 44 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 45;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 45 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 46;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 46 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 47;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 47 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 48;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 48 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_local size #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 49;
    let test = eq el #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
    if not test then failwithf "test 49 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 50;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 50 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 51;
    let test = raises in
    if not test then failwithf "test 51 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 52;
    let test = raises in
    if not test then failwithf "test 52 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 53;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 53 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 54;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 54 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 55;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 55 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 56;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 56 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic_local size 0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 57;
    let test = eq el 0n in
    if not test then failwithf "test 57 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 58;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 58 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 59;
    let test = raises in
    if not test then failwithf "test 59 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 60;
    let test = raises in
    if not test then failwithf "test 60 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 61;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 61 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 62;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 62 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 63;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 63 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 64;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 64 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************************************************************************************************************)
  (*   #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)   *)
  (**************************************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) array = makearray_dynamic_local size #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 65;
    let test = eq el #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
    if not test then failwithf "test 65 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 66;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 66 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 67;
    let test = raises in
    if not test then failwithf "test 67 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 68;
    let test = raises in
    if not test then failwithf "test 68 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 69;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 69 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 70;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 70 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 71;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 71 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 72;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 72 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************)
  (*   #(ur2 * ur1)   *)
  (********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(ur2 * ur1) array = makearray_dynamic_local size #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 73;
    let test = eq el #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
    if not test then failwithf "test 73 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 74;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 74 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 75;
    let test = raises in
    if not test then failwithf "test 75 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 76;
    let test = raises in
    if not test then failwithf "test 76 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 77;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 77 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 78;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 78 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 79;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 79 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 80;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 80 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_uninit size =
  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 81;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 81 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 82;
    let test = raises in
    if not test then failwithf "test 82 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 83;
    let test = raises in
    if not test then failwithf "test 83 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 84;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 84 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 85;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 85 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 86;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 86 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 87;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 87 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 88;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 88 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 89;
    let test = raises in
    if not test then failwithf "test 89 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 90;
    let test = raises in
    if not test then failwithf "test 90 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 91 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 92;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 92 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 93;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 93 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 94;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 94 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_uninit_local size =
  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 95;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 95 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 96;
    let test = raises in
    if not test then failwithf "test 96 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 97;
    let test = raises in
    if not test then failwithf "test 97 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 98;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 98 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 99;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 99 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 100;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 100 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 101;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 101 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 102;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 102 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 103;
    let test = raises in
    if not test then failwithf "test 103 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 104;
    let test = raises in
    if not test then failwithf "test 104 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 105;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 105 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 106;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 106 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 107;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 107 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 108;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 108 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

(* Main tests *)
let () =
  print_endline "test_makearray_dynamic";
  iter sizes ~f:test_makearray_dynamic;
  print_endline "test_makearray_dynamic_local";
  iter sizes ~f:test_makearray_dynamic_local;
  print_endline "test_makearray_dynamic_uninit";
  iter sizes ~f:test_makearray_dynamic_uninit;
  print_endline "test_makearray_dynamic_uninit_local";
  iter sizes ~f:test_makearray_dynamic_uninit_local;
  ()
;;

for i = 1 to 108 do
  if not (List.mem ~set:!tests_run i) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
