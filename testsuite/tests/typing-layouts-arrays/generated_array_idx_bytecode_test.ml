(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 flags = "-extension layouts_alpha";
 bytecode;
*)
(** This is code generated by [generate_array_idx_tests.ml]. *)



[@@@ocaml.warning "-23"]

open Stdlib_upstream_compatible
open Stdlib_stable

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] get_idx_imm :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_imm -> ('b [@local_opt]) =
  "%unsafe_get_idx_imm"

external[@layout_poly] get_idx_mut :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) =
  "%unsafe_get_idx"

external[@layout_poly] set_idx_mut :
  'a ('b : any).
    ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) -> unit =
  "%unsafe_set_idx"

module Idx_repr : sig
  type t
  val of_idx_imm : 'a ('b : any). ('a, 'b) idx_imm -> t
  val of_idx_mut : 'a ('b : any). ('a, 'b) idx_mut -> t
  val equal : t -> t -> bool
  val debug_string : t -> string
end = struct
  (* See Note [Representation of block indices] in [lambda/translcore.ml] *)
  type t =
    | Bytecode of { path : int list }
    | Native of { offset : int; gap : int }

  external magic_box_bits64 : ('a : bits64) 'b . 'a -> 'b =
    "%box_int64"
  external lessthan_if_bytecode : int -> int -> bool =
    "caml_lessthan" "caml_greaterthan"

  let of_idx idx =
    let is_bytecode = lessthan_if_bytecode 0 1 in
    if is_bytecode then
      let r = Obj.repr (magic_box_bits64 idx) in
      let nth_idx n : int = Obj.magic (Obj.field r n) in
      let path = List.init (Obj.size r) nth_idx in
      Bytecode { path }
    else
      let i : int64 = magic_box_bits64 idx in
      let offset =
        Int64.(logand (sub (shift_left one 48) one)) i
        |> Int64.to_int
      in
      let gap =
        Int64.shift_right i 48
        |> Int64.to_int
      in
      Native { offset; gap }

  let of_idx_imm = of_idx
  let of_idx_mut = of_idx

  let equal t1 t2 =
    match t1, t2 with
    | Bytecode { path = path1 }, Bytecode { path = path2 } ->
      List.equal Int.equal path1 path2
    | Native { gap = gap1; offset = offset1 },
      Native { gap = gap2; offset = offset2 } ->
      Int.equal gap1 gap2 && Int.equal offset1 offset2
    | Bytecode _, Native _ | Native _, Bytecode _ -> assert false

  let debug_string = function
    | Bytecode { path } ->
      Printf.sprintf "{ %s }"
        (String.concat "; " (List.map Int.to_string path))
    | Native { offset; gap } ->
      Printf.sprintf "offset %d; gap %d" offset gap
end

let failwithf fmt = Printf.ksprintf failwith fmt

external globalize : local_ 'a -> 'a = "%obj_dup";;

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

let tests_run = ref []

let mark_test_run test_id =
  if not (List.mem test_id !tests_run) then
    tests_run := test_id :: !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30; 31; 32 ]

let indices_in_deepening_tests = [0; 1; 2; 100_000]


type ur1 = #{ a : int64#; b : float# }
and ur2 = #{ a : int; b : int64# }
and ur3 = #{ a : int64# }
and ur4 = #{ a : ur2; b : ur3 }
and enum3 = A3_0 | A3_1 | A3_2

(* Catch metaprogramming errors early *)
let () =
  (* Check types and constants *)
  let _ : float32# = #0.s in
  let _ : float# = #0. in
  let _ : int32# = #0l in
  let _ : int64# = #0L in
  let _ : nativeint# = #0n in
  let _ : ur1 = (#{ a = #0L; b = #1. } : ur1) in
  let _ : ur3 = (#{ a = #0L } : ur3) in
  let _ : ur4 = (#{ a = (#{ a = 0; b = #1L } : ur2); b = (#{ a = #2L } : ur3) } : ur4) in
  let _ : float32 = 0.s in
  let _ : int32 = 0l in
  let _ : int64 = 0L in
  let _ : nativeint = 0n in
  let _ : int = 0 in
  let _ : enum3 = A3_0 in
  let _ : ur2 = (#{ a = 0; b = #1L } : ur2) in
  let _ : #(float# * int32# * int64#) = #(#0., #1l, #2L) in
  let _ : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) = #(#0., #(#1L, #2L), #3.s, #(#4l, #(#5.s, #6.)), #7L) in
  let _ : #(int64# * ur1) = #(#0L, (#{ a = #1L; b = #2. } : ur1)) in
  let _ : #(int * int64) = #(0, 1L) in
  let _ : #(int64 option * int32 * #(int32 * float) * float) = #(None, 1l, #(2l, 3.), 4.) in
  let _ : #(float * float * float) = #(0., 1., 2.) in
  let _ : #(float * #(float * float) * #(float * #(float * float * float))) = #(0., #(1., 2.), #(3., #(4., 5., 6.))) in
  (* Check equality and mk_value functions *)
  let eq : float32# @ local -> float32# @ local -> bool = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int (i + 0) in
  mark_test_run 1;
  let test = eq (mk_value 1) #1.s in
  if not test then failwithf "test 1 failed";
  mark_test_run 2;
  let test = eq #1.s #1.s in
  if not test then failwithf "test 2 failed";
  mark_test_run 3;
  let test = not (eq #1.s #2.s) in
  if not test then failwithf "test 3 failed";
  let eq : float# @ local -> float# @ local -> bool = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  mark_test_run 4;
  let test = eq (mk_value 1) #1. in
  if not test then failwithf "test 4 failed";
  mark_test_run 5;
  let test = eq #1. #1. in
  if not test then failwithf "test 5 failed";
  mark_test_run 6;
  let test = not (eq #1. #2.) in
  if not test then failwithf "test 6 failed";
  let eq : int32# @ local -> int32# @ local -> bool = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  mark_test_run 7;
  let test = eq (mk_value 1) #1l in
  if not test then failwithf "test 7 failed";
  mark_test_run 8;
  let test = eq #1l #1l in
  if not test then failwithf "test 8 failed";
  mark_test_run 9;
  let test = not (eq #1l #2l) in
  if not test then failwithf "test 9 failed";
  let eq : int64# @ local -> int64# @ local -> bool = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  mark_test_run 10;
  let test = eq (mk_value 1) #1L in
  if not test then failwithf "test 10 failed";
  mark_test_run 11;
  let test = eq #1L #1L in
  if not test then failwithf "test 11 failed";
  mark_test_run 12;
  let test = not (eq #1L #2L) in
  if not test then failwithf "test 12 failed";
  let eq : nativeint# @ local -> nativeint# @ local -> bool = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  mark_test_run 13;
  let test = eq (mk_value 1) #1n in
  if not test then failwithf "test 13 failed";
  mark_test_run 14;
  let test = eq #1n #1n in
  if not test then failwithf "test 14 failed";
  mark_test_run 15;
  let test = not (eq #1n #2n) in
  if not test then failwithf "test 15 failed";
  let eq : ur1 @ local -> ur1 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int (i + 0); b = Float_u.of_int (i + 1) } : ur1) in
  mark_test_run 16;
  let test = eq (mk_value 1) (#{ a = #1L; b = #2. } : ur1) in
  if not test then failwithf "test 16 failed";
  mark_test_run 17;
  let test = eq (#{ a = #1L; b = #2. } : ur1) (#{ a = #1L; b = #2. } : ur1) in
  if not test then failwithf "test 17 failed";
  mark_test_run 18;
  let test = not (eq (#{ a = #1L; b = #2. } : ur1) (#{ a = #2L; b = #3. } : ur1)) in
  if not test then failwithf "test 18 failed";
  let eq : ur3 @ local -> ur3 @ local -> bool = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int (i + 0) } : ur3) in
  mark_test_run 19;
  let test = eq (mk_value 1) (#{ a = #1L } : ur3) in
  if not test then failwithf "test 19 failed";
  mark_test_run 20;
  let test = eq (#{ a = #1L } : ur3) (#{ a = #1L } : ur3) in
  if not test then failwithf "test 20 failed";
  mark_test_run 21;
  let test = not (eq (#{ a = #1L } : ur3) (#{ a = #2L } : ur3)) in
  if not test then failwithf "test 21 failed";
  let eq : ur4 @ local -> ur4 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int.equal a b) a1 a2 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = i + 0; b = Int64_u.of_int (i + 1) } : ur2); b = (#{ a = Int64_u.of_int (i + 2) } : ur3) } : ur4) in
  mark_test_run 22;
  let test = eq (mk_value 1) (#{ a = (#{ a = 1; b = #2L } : ur2); b = (#{ a = #3L } : ur3) } : ur4) in
  if not test then failwithf "test 22 failed";
  mark_test_run 23;
  let test = eq (#{ a = (#{ a = 1; b = #2L } : ur2); b = (#{ a = #3L } : ur3) } : ur4) (#{ a = (#{ a = 1; b = #2L } : ur2); b = (#{ a = #3L } : ur3) } : ur4) in
  if not test then failwithf "test 23 failed";
  mark_test_run 24;
  let test = not (eq (#{ a = (#{ a = 1; b = #2L } : ur2); b = (#{ a = #3L } : ur3) } : ur4) (#{ a = (#{ a = 2; b = #3L } : ur2); b = (#{ a = #4L } : ur3) } : ur4)) in
  if not test then failwithf "test 24 failed";
  let eq : float32 @ local -> float32 @ local -> bool = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int (i + 0) in
  mark_test_run 25;
  let test = eq (mk_value 1) 1.s in
  if not test then failwithf "test 25 failed";
  mark_test_run 26;
  let test = eq 1.s 1.s in
  if not test then failwithf "test 26 failed";
  mark_test_run 27;
  let test = not (eq 1.s 2.s) in
  if not test then failwithf "test 27 failed";
  let eq : int32 @ local -> int32 @ local -> bool = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int (i + 0) in
  mark_test_run 28;
  let test = eq (mk_value 1) 1l in
  if not test then failwithf "test 28 failed";
  mark_test_run 29;
  let test = eq 1l 1l in
  if not test then failwithf "test 29 failed";
  mark_test_run 30;
  let test = not (eq 1l 2l) in
  if not test then failwithf "test 30 failed";
  let eq : int64 @ local -> int64 @ local -> bool = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  mark_test_run 31;
  let test = eq (mk_value 1) 1L in
  if not test then failwithf "test 31 failed";
  mark_test_run 32;
  let test = eq 1L 1L in
  if not test then failwithf "test 32 failed";
  mark_test_run 33;
  let test = not (eq 1L 2L) in
  if not test then failwithf "test 33 failed";
  let eq : nativeint @ local -> nativeint @ local -> bool = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int (i + 0) in
  mark_test_run 34;
  let test = eq (mk_value 1) 1n in
  if not test then failwithf "test 34 failed";
  mark_test_run 35;
  let test = eq 1n 1n in
  if not test then failwithf "test 35 failed";
  mark_test_run 36;
  let test = not (eq 1n 2n) in
  if not test then failwithf "test 36 failed";
  let eq : int @ local -> int @ local -> bool = (fun a b -> Int.equal a b) in
  let mk_value i = i + 0 in
  mark_test_run 37;
  let test = eq (mk_value 1) 1 in
  if not test then failwithf "test 37 failed";
  mark_test_run 38;
  let test = eq 1 1 in
  if not test then failwithf "test 38 failed";
  mark_test_run 39;
  let test = not (eq 1 2) in
  if not test then failwithf "test 39 failed";
  let eq : enum3 @ local -> enum3 @ local -> bool = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem (i + 0) 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  mark_test_run 40;
  let test = eq (mk_value 1) A3_1 in
  if not test then failwithf "test 40 failed";
  mark_test_run 41;
  let test = eq A3_1 A3_1 in
  if not test then failwithf "test 41 failed";
  mark_test_run 42;
  let test = not (eq A3_1 A3_2) in
  if not test then failwithf "test 42 failed";
  let eq : ur2 @ local -> ur2 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int.equal a b) a1 a2 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1 b2) in
  let mk_value i = (#{ a = i + 0; b = Int64_u.of_int (i + 1) } : ur2) in
  mark_test_run 43;
  let test = eq (mk_value 1) (#{ a = 1; b = #2L } : ur2) in
  if not test then failwithf "test 43 failed";
  mark_test_run 44;
  let test = eq (#{ a = 1; b = #2L } : ur2) (#{ a = 1; b = #2L } : ur2) in
  if not test then failwithf "test 44 failed";
  mark_test_run 45;
  let test = not (eq (#{ a = 1; b = #2L } : ur2) (#{ a = 2; b = #3L } : ur2)) in
  if not test then failwithf "test 45 failed";
  let eq : #(float# * int32# * int64#) @ local -> #(float# * int32# * int64#) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int (i + 0), Int32_u.of_int (i + 1), Int64_u.of_int (i + 2)) in
  mark_test_run 46;
  let test = eq (mk_value 1) #(#1., #2l, #3L) in
  if not test then failwithf "test 46 failed";
  mark_test_run 47;
  let test = eq #(#1., #2l, #3L) #(#1., #2l, #3L) in
  if not test then failwithf "test 47 failed";
  mark_test_run 48;
  let test = not (eq #(#1., #2l, #3L) #(#2., #3l, #4L)) in
  if not test then failwithf "test 48 failed";
  let eq : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int (i + 0), #(Int64_u.of_int (i + 1), Int64_u.of_int (i + 2)), Float32_u.of_int (i + 3), #(Int32_u.of_int (i + 4), #(Float32_u.of_int (i + 5), Float_u.of_int (i + 6))), Int64_u.of_int (i + 7)) in
  mark_test_run 49;
  let test = eq (mk_value 1) #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) in
  if not test then failwithf "test 49 failed";
  mark_test_run 50;
  let test = eq #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) in
  if not test then failwithf "test 50 failed";
  mark_test_run 51;
  let test = not (eq #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) #(#2., #(#3L, #4L), #5.s, #(#6l, #(#7.s, #8.)), #9L)) in
  if not test then failwithf "test 51 failed";
  let eq : #(int64# * ur1) @ local -> #(int64# * ur1) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int (i + 0), (#{ a = Int64_u.of_int (i + 1); b = Float_u.of_int (i + 2) } : ur1)) in
  mark_test_run 52;
  let test = eq (mk_value 1) #(#1L, (#{ a = #2L; b = #3. } : ur1)) in
  if not test then failwithf "test 52 failed";
  mark_test_run 53;
  let test = eq #(#1L, (#{ a = #2L; b = #3. } : ur1)) #(#1L, (#{ a = #2L; b = #3. } : ur1)) in
  if not test then failwithf "test 53 failed";
  mark_test_run 54;
  let test = not (eq #(#1L, (#{ a = #2L; b = #3. } : ur1)) #(#2L, (#{ a = #3L; b = #4. } : ur1))) in
  if not test then failwithf "test 54 failed";
  let eq : #(int * int64) @ local -> #(int * int64) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i + 0, Int64.of_int (i + 1)) in
  mark_test_run 55;
  let test = eq (mk_value 1) #(1, 2L) in
  if not test then failwithf "test 55 failed";
  mark_test_run 56;
  let test = eq #(1, 2L) #(1, 2L) in
  if not test then failwithf "test 56 failed";
  mark_test_run 57;
  let test = not (eq #(1, 2L) #(2, 3L)) in
  if not test then failwithf "test 57 failed";
  let eq : #(int64 option * int32 * #(int32 * float) * float) @ local -> #(int64 option * int32 * #(int32 * float) * float) @ local -> bool = (fun #(a0, a1, a2, a3) #(b0, b1, b2, b3) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a2 b2 && (fun a b -> Float.equal (globalize a) (globalize b)) a3 b3) in
  let mk_value i = #((if (i + 0) == 0 then None else Some (Int64.of_int (i + 0))), Int32.of_int (i + 1), #(Int32.of_int (i + 2), Float.of_int (i + 3)), Float.of_int (i + 4)) in
  mark_test_run 58;
  let test = eq (mk_value 1) #(Some 1L, 2l, #(3l, 4.), 5.) in
  if not test then failwithf "test 58 failed";
  mark_test_run 59;
  let test = eq #(Some 1L, 2l, #(3l, 4.), 5.) #(Some 1L, 2l, #(3l, 4.), 5.) in
  if not test then failwithf "test 59 failed";
  mark_test_run 60;
  let test = not (eq #(Some 1L, 2l, #(3l, 4.), 5.) #(Some 2L, 3l, #(4l, 5.), 6.)) in
  if not test then failwithf "test 60 failed";
  let eq : #(float * float * float) @ local -> #(float * float * float) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), Float.of_int (i + 1), Float.of_int (i + 2)) in
  mark_test_run 61;
  let test = eq (mk_value 1) #(1., 2., 3.) in
  if not test then failwithf "test 61 failed";
  mark_test_run 62;
  let test = eq #(1., 2., 3.) #(1., 2., 3.) in
  if not test then failwithf "test 62 failed";
  mark_test_run 63;
  let test = not (eq #(1., 2., 3.) #(2., 3., 4.)) in
  if not test then failwithf "test 63 failed";
  let eq : #(float * #(float * float) * #(float * #(float * float * float))) @ local -> #(float * #(float * float) * #(float * #(float * float * float))) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), #(Float.of_int (i + 1), Float.of_int (i + 2)), #(Float.of_int (i + 3), #(Float.of_int (i + 4), Float.of_int (i + 5), Float.of_int (i + 6)))) in
  mark_test_run 64;
  let test = eq (mk_value 1) #(1., #(2., 3.), #(4., #(5., 6., 7.))) in
  if not test then failwithf "test 64 failed";
  mark_test_run 65;
  let test = eq #(1., #(2., 3.), #(4., #(5., 6., 7.))) #(1., #(2., 3.), #(4., #(5., 6., 7.))) in
  if not test then failwithf "test 65 failed";
  mark_test_run 66;
  let test = not (eq #(1., #(2., 3.), #(4., #(5., 6., 7.))) #(2., #(3., 4.), #(5., #(6., 7., 8.)))) in
  if not test then failwithf "test 66 failed";
  ()
;;

let test_array_idx_with_makearray_dynamic size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic size #0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 67;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 67 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 68;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 68 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic size #0. in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 69;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 69 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 70;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 70 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 71;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 71 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 72;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 72 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 73;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 73 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 74;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 74 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 75;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 75 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 76;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 76 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int (i + 0); b = Float_u.of_int (i + 1) } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic size (#{ a = #0L; b = #1. } : ur1) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 77;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 77 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 78;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 78 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur1 array, _) idx_mut) next_el.#a;
    mark_test_run 79;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 79 failed %d %d" size i;
    (* .#b *)
    let el = #{ el with b = next_el.#b } in
    set_idx_mut a ((.(i).#b) : (ur1 array, _) idx_mut) next_el.#b;
    mark_test_run 80;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 80 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int (i + 0) } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic size (#{ a = #0L } : ur3) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 81;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 81 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 82;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 82 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur3 array, _) idx_mut) next_el.#a;
    mark_test_run 83;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 83 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int.equal a b) a1 a2 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = i + 0; b = Int64_u.of_int (i + 1) } : ur2); b = (#{ a = Int64_u.of_int (i + 2) } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic size (#{ a = (#{ a = 0; b = #1L } : ur2); b = (#{ a = #2L } : ur3) } : ur4) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 84;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 84 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 85;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 85 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur4 array, _) idx_mut) next_el.#a;
    mark_test_run 86;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 86 failed %d %d" size i;
    (* .#b *)
    let el = #{ el with b = next_el.#b } in
    set_idx_mut a ((.(i).#b) : (ur4 array, _) idx_mut) next_el.#b;
    mark_test_run 87;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 87 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a.#a *)
    let el = #{ el with a = #{ el.#a with a = next_el.#a.#a } } in
    set_idx_mut a ((.(i).#a.#a) : (ur4 array, _) idx_mut) next_el.#a.#a;
    mark_test_run 88;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 88 failed %d %d" size i;
    (* .#a.#b *)
    let el = #{ el with a = #{ el.#a with b = next_el.#a.#b } } in
    set_idx_mut a ((.(i).#a.#b) : (ur4 array, _) idx_mut) next_el.#a.#b;
    mark_test_run 89;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 89 failed %d %d" size i;
    (* .#b.#a *)
    let el = #{ el with b = #{ el.#b with a = next_el.#b.#a } } in
    set_idx_mut a ((.(i).#b.#a) : (ur4 array, _) idx_mut) next_el.#b.#a;
    mark_test_run 90;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 90 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic size 0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 91 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 92;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 92 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic size 0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 93;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 93 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 94;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 94 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 95;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 95 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 96 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic size 0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 97;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 97 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 98;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 98 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = i + 0 in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 99;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 99 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 100;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 100 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   enum3   *)
  (*************)
  let eq = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem (i + 0) 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  (* 1. Create an array of size [size] *)
  let a : enum3 array = makearray_dynamic size A3_0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 101;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 101 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 102;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 102 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur2   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int.equal a b) a1 a2 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1 b2) in
  let mk_value i = (#{ a = i + 0; b = Int64_u.of_int (i + 1) } : ur2) in
  (* 1. Create an array of size [size] *)
  let a : ur2 array = makearray_dynamic size (#{ a = 0; b = #1L } : ur2) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 103;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 103 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 104;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 104 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur2 array, _) idx_mut) next_el.#a;
    mark_test_run 105;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* .#b *)
    let el = #{ el with b = next_el.#b } in
    set_idx_mut a ((.(i).#b) : (ur2 array, _) idx_mut) next_el.#b;
    mark_test_run 106;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 106 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int (i + 0), Int32_u.of_int (i + 1), Int64_u.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic size #(#0., #1l, #2L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 108;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 108 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int (i + 0), #(Int64_u.of_int (i + 1), Int64_u.of_int (i + 2)), Float32_u.of_int (i + 3), #(Int32_u.of_int (i + 4), #(Float32_u.of_int (i + 5), Float_u.of_int (i + 6))), Int64_u.of_int (i + 7)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic size #(#0., #(#1L, #2L), #3.s, #(#4l, #(#5.s, #6.)), #7L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 109;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 109 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 110;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 110 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int (i + 0), (#{ a = Int64_u.of_int (i + 1); b = Float_u.of_int (i + 2) } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic size #(#0L, (#{ a = #1L; b = #2. } : ur1)) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 111;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 111 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 112;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 112 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i + 0, Int64.of_int (i + 1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic size #(0, 1L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 113;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 113 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 114;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 114 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************************************************)
  (*   #(int64 option * int32 * #(int32 * float) * float)   *)
  (**********************************************************)
  let eq = (fun #(a0, a1, a2, a3) #(b0, b1, b2, b3) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a2 b2 && (fun a b -> Float.equal (globalize a) (globalize b)) a3 b3) in
  let mk_value i = #((if (i + 0) == 0 then None else Some (Int64.of_int (i + 0))), Int32.of_int (i + 1), #(Int32.of_int (i + 2), Float.of_int (i + 3)), Float.of_int (i + 4)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * int32 * #(int32 * float) * float) array = makearray_dynamic size #(None, 1l, #(2l, 3.), 4.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 115;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 115 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 116;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 116 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), Float.of_int (i + 1), Float.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic size #(0., 1., 2.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 117;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 117 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 118;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 118 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), #(Float.of_int (i + 1), Float.of_int (i + 2)), #(Float.of_int (i + 3), #(Float.of_int (i + 4), Float.of_int (i + 5), Float.of_int (i + 6)))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic size #(0., #(1., 2.), #(3., #(4., 5., 6.))) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 119;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 119 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  ()

let test_array_idx_with_makearray_dynamic_local size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_local size #0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 121;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 121 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 122;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 122 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_local size #0. in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 123;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 123 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 124;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 124 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 125;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 125 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 126;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 126 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 127;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 127 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 128;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 128 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 129;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 129 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 130;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 130 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int (i + 0); b = Float_u.of_int (i + 1) } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_local size (#{ a = #0L; b = #1. } : ur1) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 131 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 132;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 132 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur1 array, _) idx_mut) next_el.#a;
    mark_test_run 133;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 133 failed %d %d" size i;
    (* .#b *)
    let el = #{ el with b = next_el.#b } in
    set_idx_mut a ((.(i).#b) : (ur1 array, _) idx_mut) next_el.#b;
    mark_test_run 134;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 134 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int (i + 0) } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_local size (#{ a = #0L } : ur3) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 135;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 135 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 136;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 136 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur3 array, _) idx_mut) next_el.#a;
    mark_test_run 137;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 137 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int.equal a b) a1 a2 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = i + 0; b = Int64_u.of_int (i + 1) } : ur2); b = (#{ a = Int64_u.of_int (i + 2) } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_local size (#{ a = (#{ a = 0; b = #1L } : ur2); b = (#{ a = #2L } : ur3) } : ur4) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 138;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 138 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 139;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 139 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur4 array, _) idx_mut) next_el.#a;
    mark_test_run 140;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 140 failed %d %d" size i;
    (* .#b *)
    let el = #{ el with b = next_el.#b } in
    set_idx_mut a ((.(i).#b) : (ur4 array, _) idx_mut) next_el.#b;
    mark_test_run 141;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 141 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a.#a *)
    let el = #{ el with a = #{ el.#a with a = next_el.#a.#a } } in
    set_idx_mut a ((.(i).#a.#a) : (ur4 array, _) idx_mut) next_el.#a.#a;
    mark_test_run 142;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 142 failed %d %d" size i;
    (* .#a.#b *)
    let el = #{ el with a = #{ el.#a with b = next_el.#a.#b } } in
    set_idx_mut a ((.(i).#a.#b) : (ur4 array, _) idx_mut) next_el.#a.#b;
    mark_test_run 143;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 143 failed %d %d" size i;
    (* .#b.#a *)
    let el = #{ el with b = #{ el.#b with a = next_el.#b.#a } } in
    set_idx_mut a ((.(i).#b.#a) : (ur4 array, _) idx_mut) next_el.#b.#a;
    mark_test_run 144;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 144 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic_local size 0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 145;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 145 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 146;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 146 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic_local size 0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 147;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 147 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 148;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 148 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 149;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 149 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 150;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 150 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic_local size 0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 151;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 151 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 152;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 152 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = i + 0 in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 153;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 153 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 154;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 154 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   enum3   *)
  (*************)
  let eq = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem (i + 0) 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  (* 1. Create an array of size [size] *)
  let a : enum3 array = makearray_dynamic_local size A3_0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 155;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 155 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 156;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 156 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   ur2   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int.equal a b) a1 a2 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1 b2) in
  let mk_value i = (#{ a = i + 0; b = Int64_u.of_int (i + 1) } : ur2) in
  (* 1. Create an array of size [size] *)
  let a : ur2 array = makearray_dynamic_local size (#{ a = 0; b = #1L } : ur2) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 157;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 157 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 158;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 158 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a *)
    let el = #{ el with a = next_el.#a } in
    set_idx_mut a ((.(i).#a) : (ur2 array, _) idx_mut) next_el.#a;
    mark_test_run 159;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 159 failed %d %d" size i;
    (* .#b *)
    let el = #{ el with b = next_el.#b } in
    set_idx_mut a ((.(i).#b) : (ur2 array, _) idx_mut) next_el.#b;
    mark_test_run 160;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 160 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int (i + 0), Int32_u.of_int (i + 1), Int64_u.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_local size #(#0., #1l, #2L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 161;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 161 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 162;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 162 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int (i + 0), #(Int64_u.of_int (i + 1), Int64_u.of_int (i + 2)), Float32_u.of_int (i + 3), #(Int32_u.of_int (i + 4), #(Float32_u.of_int (i + 5), Float_u.of_int (i + 6))), Int64_u.of_int (i + 7)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_local size #(#0., #(#1L, #2L), #3.s, #(#4l, #(#5.s, #6.)), #7L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 163;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 163 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 164;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 164 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int (i + 0), (#{ a = Int64_u.of_int (i + 1); b = Float_u.of_int (i + 2) } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_local size #(#0L, (#{ a = #1L; b = #2. } : ur1)) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 165;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 165 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 166;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 166 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i + 0, Int64.of_int (i + 1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic_local size #(0, 1L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 167;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 167 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 168;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 168 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************************************************)
  (*   #(int64 option * int32 * #(int32 * float) * float)   *)
  (**********************************************************)
  let eq = (fun #(a0, a1, a2, a3) #(b0, b1, b2, b3) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a2 b2 && (fun a b -> Float.equal (globalize a) (globalize b)) a3 b3) in
  let mk_value i = #((if (i + 0) == 0 then None else Some (Int64.of_int (i + 0))), Int32.of_int (i + 1), #(Int32.of_int (i + 2), Float.of_int (i + 3)), Float.of_int (i + 4)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * int32 * #(int32 * float) * float) array = makearray_dynamic_local size #(None, 1l, #(2l, 3.), 4.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 169;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 169 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 170;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 170 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), Float.of_int (i + 1), Float.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic_local size #(0., 1., 2.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 171;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 171 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 172;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 172 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), #(Float.of_int (i + 1), Float.of_int (i + 2)), #(Float.of_int (i + 3), #(Float.of_int (i + 4), Float.of_int (i + 5), Float.of_int (i + 6)))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic_local size #(0., #(1., 2.), #(3., #(4., 5., 6.))) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 173;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 173 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 174;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 174 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  ()

(* Test array idx deepening *)
let () =
  (****************)
  (*   float32#   *)
  (****************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (float32# array, _) idx_mut = (.(i)) in
    let shallow : (float32# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 175;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 175 failed";
  );

  (**************)
  (*   float#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (float# array, _) idx_mut = (.(i)) in
    let shallow : (float# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 176;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 176 failed";
  );

  (**************)
  (*   int32#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int32# array, _) idx_mut = (.(i)) in
    let shallow : (int32# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 177;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 177 failed";
  );

  (**************)
  (*   int64#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64# array, _) idx_mut = (.(i)) in
    let shallow : (int64# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 178;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 178 failed";
  );

  (******************)
  (*   nativeint#   *)
  (******************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (nativeint# array, _) idx_mut = (.(i)) in
    let shallow : (nativeint# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 179;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 179 failed";
  );

  (***********)
  (*   ur1   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur1 array, _) idx_mut = (.(i)) in
    let shallow : (ur1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 180;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 180 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur1 array, _) idx_mut = (.(i).#a) in
    let shallow : (ur1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a) in
    mark_test_run 181;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 181 failed";
    let shallow : (ur1 array, _) idx_mut = (.(i).#a) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 182;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 182 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur1 array, _) idx_mut = (.(i).#b) in
    let shallow : (ur1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b) in
    mark_test_run 183;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 183 failed";
    let shallow : (ur1 array, _) idx_mut = (.(i).#b) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 184;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 184 failed";
  );

  (***********)
  (*   ur3   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur3 array, _) idx_mut = (.(i)) in
    let shallow : (ur3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 185;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 185 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur3 array, _) idx_mut = (.(i).#a) in
    let shallow : (ur3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a) in
    mark_test_run 186;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 186 failed";
    let shallow : (ur3 array, _) idx_mut = (.(i).#a) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 187;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 187 failed";
  );

  (***********)
  (*   ur4   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur4 array, _) idx_mut = (.(i)) in
    let shallow : (ur4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 188;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 188 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur4 array, _) idx_mut = (.(i).#a) in
    let shallow : (ur4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a) in
    mark_test_run 189;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 189 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#a) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 190;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 190 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur4 array, _) idx_mut = (.(i).#b) in
    let shallow : (ur4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b) in
    mark_test_run 191;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 191 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#b) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 192;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 192 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur4 array, _) idx_mut = (.(i).#a.#a) in
    let shallow : (ur4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a.#a) in
    mark_test_run 193;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 193 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#a) in
    let deepened = (.idx_mut(shallow).#a) in
    mark_test_run 194;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 194 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#a.#a) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 195;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 195 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur4 array, _) idx_mut = (.(i).#a.#b) in
    let shallow : (ur4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a.#b) in
    mark_test_run 196;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 196 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#a) in
    let deepened = (.idx_mut(shallow).#b) in
    mark_test_run 197;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 197 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#a.#b) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 198;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 198 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur4 array, _) idx_mut = (.(i).#b.#a) in
    let shallow : (ur4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b.#a) in
    mark_test_run 199;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 199 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#b) in
    let deepened = (.idx_mut(shallow).#a) in
    mark_test_run 200;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 200 failed";
    let shallow : (ur4 array, _) idx_mut = (.(i).#b.#a) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 201;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 201 failed";
  );

  (***************)
  (*   float32   *)
  (***************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (float32 array, _) idx_mut = (.(i)) in
    let shallow : (float32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 202;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 202 failed";
  );

  (*************)
  (*   int32   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int32 array, _) idx_mut = (.(i)) in
    let shallow : (int32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 203;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 203 failed";
  );

  (*************)
  (*   int64   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64 array, _) idx_mut = (.(i)) in
    let shallow : (int64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 204;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 204 failed";
  );

  (*****************)
  (*   nativeint   *)
  (*****************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (nativeint array, _) idx_mut = (.(i)) in
    let shallow : (nativeint array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 205;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 205 failed";
  );

  (***********)
  (*   int   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int array, _) idx_mut = (.(i)) in
    let shallow : (int array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 206;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 206 failed";
  );

  (*************)
  (*   enum3   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (enum3 array, _) idx_mut = (.(i)) in
    let shallow : (enum3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 207;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 207 failed";
  );

  (***********)
  (*   ur2   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur2 array, _) idx_mut = (.(i)) in
    let shallow : (ur2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 208;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 208 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur2 array, _) idx_mut = (.(i).#a) in
    let shallow : (ur2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a) in
    mark_test_run 209;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 209 failed";
    let shallow : (ur2 array, _) idx_mut = (.(i).#a) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 210;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 210 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (ur2 array, _) idx_mut = (.(i).#b) in
    let shallow : (ur2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b) in
    mark_test_run 211;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 211 failed";
    let shallow : (ur2 array, _) idx_mut = (.(i).#b) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 212;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 212 failed";
  );

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float# * int32# * int64#) array, _) idx_mut = (.(i)) in
    let shallow : (#(float# * int32# * int64#) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 213;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 213 failed";
  );

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array, _) idx_mut = (.(i)) in
    let shallow : (#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 214;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 214 failed";
  );

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(int64# * ur1) array, _) idx_mut = (.(i)) in
    let shallow : (#(int64# * ur1) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 215;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 215 failed";
  );

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(int * int64) array, _) idx_mut = (.(i)) in
    let shallow : (#(int * int64) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 216;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 216 failed";
  );

  (**********************************************************)
  (*   #(int64 option * int32 * #(int32 * float) * float)   *)
  (**********************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(int64 option * int32 * #(int32 * float) * float) array, _) idx_mut = (.(i)) in
    let shallow : (#(int64 option * int32 * #(int32 * float) * float) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 217;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 217 failed";
  );

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float * float * float) array, _) idx_mut = (.(i)) in
    let shallow : (#(float * float * float) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 218;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 218 failed";
  );

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float * #(float * float) * #(float * #(float * float * float))) array, _) idx_mut = (.(i)) in
    let shallow : (#(float * #(float * float) * #(float * #(float * float * float))) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 219;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 219 failed";
  );

  ()
(* *)
let () =
  print_endline "test_array_idx_with_makearray_dynamic";
  iter sizes ~f:test_array_idx_with_makearray_dynamic;
  print_endline "test_array_idx_with_makearray_dynamic_local";
  iter sizes ~f:test_array_idx_with_makearray_dynamic_local;
  ()
;;

for i = 1 to 219 do
  if not (List.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
